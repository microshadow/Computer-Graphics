// Set the pixel color to an interesting procedural color generated by mixing
// and filtering Perlin noise of different frequencies.
//
// Uniforms:
uniform mat4 view;
uniform mat4 proj;
uniform float animation_seconds;
uniform bool is_moon;
// Inputs:
in vec3 sphere_fs_in;
in vec3 normal_fs_in;
in vec4 pos_fs_in; 
in vec4 view_pos_fs_in; 
// Outputs:
out vec3 color;

// expects: blinn_phong, perlin_noise
void main()
{
  /////////////////////////////////////////////////////////////////////////////
  // Replace with your code 

	// same as lit.fs
	float theta = M_PI * 0.5 * animation_seconds;
	mat3 rotation = mat3(cos(theta), 0, -sin(theta),
		                   0, 1, 0,
		                   sin(theta), 0, cos(theta));

	vec3 n_prime = normalize((proj * vec4(normal_fs_in, 1.0)).xyz / (proj * vec4(normal_fs_in, 1.0)).w);
	vec3 v_prime = normalize((proj * view_pos_fs_in).xyz / (proj * view_pos_fs_in).w);
	vec3 l_prime = normalize(rotation * vec3(2.0, 0.0, 0.0));

	//noise
	float noise1 = perlin_noise(2.4 * sphere_fs_in + vec3(1.0, 1.0, 1.0));
	float noise2 = perlin_noise(1.7 * sphere_fs_in + vec3(0.1, 0.1, 0.1));

	vec3 k_d;  // kd
	if(!is_moon){
		k_d = vec3(0.0, 0.0, 1.0);
		k_d = max(min(k_d, abs(k_d - min(noise1, 0.72))), min(k_d + noise2, vec3(0.25, 0.5, 1.0)));
	}else{
		// considering moon
		k_d = vec3(0.55, 0.55, 0.55);
		k_d = max(min(k_d, abs(k_d - min(noise1, 0.72))), min(k_d + noise2, vec3(0.75, 0.75, 0.75)));
	}

  	color = blinn_phong(vec3(0.05, 0.05, 0.05), k_d, vec3(0.75, 0.75, 0.75), 100, n_prime, v_prime, l_prime);

  /////////////////////////////////////////////////////////////////////////////
}
